schema {
  query: Query
  mutation: Mutation
}

type AssignmentArea {
  ChildAreas(cursor: AssignmentAreaWhereUniqueInput, distinct: [AssignmentAreaScalarFieldEnum!], orderBy: [AssignmentAreaOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentAreaWhereInput): [AssignmentArea!]!
  ParentArea: AssignmentArea
  ParentAreaId: String
  User(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  id: ID!
  machineName: String!
  name: String!
  updatedAt: DateTime!
}

input AssignmentAreaCountOrderByAggregateInput {
  ParentAreaId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AssignmentAreaCreateInput {
  ChildAreas: AssignmentAreaCreateNestedManyWithoutParentAreaInput
  ParentArea: AssignmentAreaCreateNestedOneWithoutChildAreasInput
  User: UserCreateNestedManyWithoutAssignmentAreaInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaCreateManyInput {
  ParentAreaId: String
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaCreateManyParentAreaInput {
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaCreateManyParentAreaInputEnvelope {
  data: [AssignmentAreaCreateManyParentAreaInput!]!
  skipDuplicates: Boolean
}

input AssignmentAreaCreateNestedManyWithoutParentAreaInput {
  connect: [AssignmentAreaWhereUniqueInput!]
  connectOrCreate: [AssignmentAreaCreateOrConnectWithoutParentAreaInput!]
  create: [AssignmentAreaCreateWithoutParentAreaInput!]
  createMany: AssignmentAreaCreateManyParentAreaInputEnvelope
}

input AssignmentAreaCreateNestedOneWithoutChildAreasInput {
  connect: AssignmentAreaWhereUniqueInput
  connectOrCreate: AssignmentAreaCreateOrConnectWithoutChildAreasInput
  create: AssignmentAreaCreateWithoutChildAreasInput
}

input AssignmentAreaCreateNestedOneWithoutUserInput {
  connect: AssignmentAreaWhereUniqueInput
  connectOrCreate: AssignmentAreaCreateOrConnectWithoutUserInput
  create: AssignmentAreaCreateWithoutUserInput
}

input AssignmentAreaCreateOrConnectWithoutChildAreasInput {
  create: AssignmentAreaCreateWithoutChildAreasInput!
  where: AssignmentAreaWhereUniqueInput!
}

input AssignmentAreaCreateOrConnectWithoutParentAreaInput {
  create: AssignmentAreaCreateWithoutParentAreaInput!
  where: AssignmentAreaWhereUniqueInput!
}

input AssignmentAreaCreateOrConnectWithoutUserInput {
  create: AssignmentAreaCreateWithoutUserInput!
  where: AssignmentAreaWhereUniqueInput!
}

input AssignmentAreaCreateWithoutChildAreasInput {
  ParentArea: AssignmentAreaCreateNestedOneWithoutChildAreasInput
  User: UserCreateNestedManyWithoutAssignmentAreaInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaCreateWithoutParentAreaInput {
  ChildAreas: AssignmentAreaCreateNestedManyWithoutParentAreaInput
  User: UserCreateNestedManyWithoutAssignmentAreaInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaCreateWithoutUserInput {
  ChildAreas: AssignmentAreaCreateNestedManyWithoutParentAreaInput
  ParentArea: AssignmentAreaCreateNestedOneWithoutChildAreasInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input AssignmentAreaListRelationFilter {
  every: AssignmentAreaWhereInput
  none: AssignmentAreaWhereInput
  some: AssignmentAreaWhereInput
}

input AssignmentAreaMaxOrderByAggregateInput {
  ParentAreaId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AssignmentAreaMinOrderByAggregateInput {
  ParentAreaId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AssignmentAreaNullableRelationFilter {
  is: AssignmentAreaWhereInput
  isNot: AssignmentAreaWhereInput
}

input AssignmentAreaOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssignmentAreaOrderByWithAggregationInput {
  ParentAreaId: SortOrder
  _count: AssignmentAreaCountOrderByAggregateInput
  _max: AssignmentAreaMaxOrderByAggregateInput
  _min: AssignmentAreaMinOrderByAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AssignmentAreaOrderByWithRelationInput {
  ChildAreas: AssignmentAreaOrderByRelationAggregateInput
  ParentArea: AssignmentAreaOrderByWithRelationInput
  ParentAreaId: SortOrder
  User: UserOrderByRelationAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

enum AssignmentAreaScalarFieldEnum {
  ParentAreaId
  createdAt
  deleteAt
  description
  id
  machineName
  name
  updatedAt
}

input AssignmentAreaScalarWhereInput {
  AND: [AssignmentAreaScalarWhereInput!]
  NOT: [AssignmentAreaScalarWhereInput!]
  OR: [AssignmentAreaScalarWhereInput!]
  ParentAreaId: StringNullableFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentAreaScalarWhereWithAggregatesInput {
  AND: [AssignmentAreaScalarWhereWithAggregatesInput!]
  NOT: [AssignmentAreaScalarWhereWithAggregatesInput!]
  OR: [AssignmentAreaScalarWhereWithAggregatesInput!]
  ParentAreaId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  machineName: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input AssignmentAreaUpdateInput {
  ChildAreas: AssignmentAreaUpdateManyWithoutParentAreaNestedInput
  ParentArea: AssignmentAreaUpdateOneWithoutChildAreasNestedInput
  User: UserUpdateManyWithoutAssignmentAreaNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentAreaUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentAreaUpdateManyWithWhereWithoutParentAreaInput {
  data: AssignmentAreaUpdateManyMutationInput!
  where: AssignmentAreaScalarWhereInput!
}

input AssignmentAreaUpdateManyWithoutParentAreaNestedInput {
  connect: [AssignmentAreaWhereUniqueInput!]
  connectOrCreate: [AssignmentAreaCreateOrConnectWithoutParentAreaInput!]
  create: [AssignmentAreaCreateWithoutParentAreaInput!]
  createMany: AssignmentAreaCreateManyParentAreaInputEnvelope
  delete: [AssignmentAreaWhereUniqueInput!]
  deleteMany: [AssignmentAreaScalarWhereInput!]
  disconnect: [AssignmentAreaWhereUniqueInput!]
  set: [AssignmentAreaWhereUniqueInput!]
  update: [AssignmentAreaUpdateWithWhereUniqueWithoutParentAreaInput!]
  updateMany: [AssignmentAreaUpdateManyWithWhereWithoutParentAreaInput!]
  upsert: [AssignmentAreaUpsertWithWhereUniqueWithoutParentAreaInput!]
}

input AssignmentAreaUpdateOneWithoutChildAreasNestedInput {
  connect: AssignmentAreaWhereUniqueInput
  connectOrCreate: AssignmentAreaCreateOrConnectWithoutChildAreasInput
  create: AssignmentAreaCreateWithoutChildAreasInput
  delete: AssignmentAreaWhereInput
  disconnect: AssignmentAreaWhereInput
  update: AssignmentAreaUpdateToOneWithWhereWithoutChildAreasInput
  upsert: AssignmentAreaUpsertWithoutChildAreasInput
}

input AssignmentAreaUpdateOneWithoutUserNestedInput {
  connect: AssignmentAreaWhereUniqueInput
  connectOrCreate: AssignmentAreaCreateOrConnectWithoutUserInput
  create: AssignmentAreaCreateWithoutUserInput
  delete: AssignmentAreaWhereInput
  disconnect: AssignmentAreaWhereInput
  update: AssignmentAreaUpdateToOneWithWhereWithoutUserInput
  upsert: AssignmentAreaUpsertWithoutUserInput
}

input AssignmentAreaUpdateToOneWithWhereWithoutChildAreasInput {
  data: AssignmentAreaUpdateWithoutChildAreasInput!
  where: AssignmentAreaWhereInput
}

input AssignmentAreaUpdateToOneWithWhereWithoutUserInput {
  data: AssignmentAreaUpdateWithoutUserInput!
  where: AssignmentAreaWhereInput
}

input AssignmentAreaUpdateWithWhereUniqueWithoutParentAreaInput {
  data: AssignmentAreaUpdateWithoutParentAreaInput!
  where: AssignmentAreaWhereUniqueInput!
}

input AssignmentAreaUpdateWithoutChildAreasInput {
  ParentArea: AssignmentAreaUpdateOneWithoutChildAreasNestedInput
  User: UserUpdateManyWithoutAssignmentAreaNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentAreaUpdateWithoutParentAreaInput {
  ChildAreas: AssignmentAreaUpdateManyWithoutParentAreaNestedInput
  User: UserUpdateManyWithoutAssignmentAreaNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentAreaUpdateWithoutUserInput {
  ChildAreas: AssignmentAreaUpdateManyWithoutParentAreaNestedInput
  ParentArea: AssignmentAreaUpdateOneWithoutChildAreasNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentAreaUpsertWithWhereUniqueWithoutParentAreaInput {
  create: AssignmentAreaCreateWithoutParentAreaInput!
  update: AssignmentAreaUpdateWithoutParentAreaInput!
  where: AssignmentAreaWhereUniqueInput!
}

input AssignmentAreaUpsertWithoutChildAreasInput {
  create: AssignmentAreaCreateWithoutChildAreasInput!
  update: AssignmentAreaUpdateWithoutChildAreasInput!
  where: AssignmentAreaWhereInput
}

input AssignmentAreaUpsertWithoutUserInput {
  create: AssignmentAreaCreateWithoutUserInput!
  update: AssignmentAreaUpdateWithoutUserInput!
  where: AssignmentAreaWhereInput
}

input AssignmentAreaWhereInput {
  AND: [AssignmentAreaWhereInput!]
  ChildAreas: AssignmentAreaListRelationFilter
  NOT: [AssignmentAreaWhereInput!]
  OR: [AssignmentAreaWhereInput!]
  ParentArea: AssignmentAreaWhereInput
  ParentAreaId: StringNullableFilter
  User: UserListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentAreaWhereUniqueInput {
  AND: [AssignmentAreaWhereInput!]
  ChildAreas: AssignmentAreaListRelationFilter
  NOT: [AssignmentAreaWhereInput!]
  OR: [AssignmentAreaWhereInput!]
  ParentArea: AssignmentAreaWhereInput
  ParentAreaId: StringNullableFilter
  User: UserListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: String
  machineName: String
  name: String
  updatedAt: DateTimeFilter
}

"""Batch payloads from prisma."""
type BatchPayload {
  """Prisma Batch Payload"""
  count: Int!
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

scalar Json

input JsonFilter {
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

enum JsonNullValueFilter {
  AnyNull
  DbNull
  JsonNull
}

enum JsonNullValueInput {
  JsonNull
}

input JsonNullableFilter {
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedJsonNullableFilter
  _min: NestedJsonNullableFilter
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Level {
  Category: LevelCategory!
  ChildLevels(cursor: LevelWhereUniqueInput, distinct: [LevelScalarFieldEnum!], orderBy: [LevelOrderByWithRelationInput!], skip: Int, take: Int, where: LevelWhereInput): [Level!]!
  ParentLevel: Level
  ParentLevelId: String
  Project(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  advance: Int!
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  id: ID!
  levelCategoryId: String!
  machineName: String!
  name: String!
  percentage: Int!
  updatedAt: DateTime!
}

input LevelAvgOrderByAggregateInput {
  advance: SortOrder
  percentage: SortOrder
}

type LevelCategory {
  ChildCategories(cursor: LevelCategoryWhereUniqueInput, distinct: [LevelCategoryScalarFieldEnum!], orderBy: [LevelCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: LevelCategoryWhereInput): [LevelCategory!]!
  Levels(cursor: LevelWhereUniqueInput, distinct: [LevelScalarFieldEnum!], orderBy: [LevelOrderByWithRelationInput!], skip: Int, take: Int, where: LevelWhereInput): [Level!]!
  ParentCategory: LevelCategory
  ParentCategoryId: String
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  id: ID!
  machineName: String!
  name: String!
  updatedAt: DateTime!
}

input LevelCategoryCountOrderByAggregateInput {
  ParentCategoryId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LevelCategoryCreateInput {
  ChildCategories: LevelCategoryCreateNestedManyWithoutParentCategoryInput
  Levels: LevelCreateNestedManyWithoutCategoryInput
  ParentCategory: LevelCategoryCreateNestedOneWithoutChildCategoriesInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryCreateManyInput {
  ParentCategoryId: String
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryCreateManyParentCategoryInput {
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryCreateManyParentCategoryInputEnvelope {
  data: [LevelCategoryCreateManyParentCategoryInput!]!
  skipDuplicates: Boolean
}

input LevelCategoryCreateNestedManyWithoutParentCategoryInput {
  connect: [LevelCategoryWhereUniqueInput!]
  connectOrCreate: [LevelCategoryCreateOrConnectWithoutParentCategoryInput!]
  create: [LevelCategoryCreateWithoutParentCategoryInput!]
  createMany: LevelCategoryCreateManyParentCategoryInputEnvelope
}

input LevelCategoryCreateNestedOneWithoutChildCategoriesInput {
  connect: LevelCategoryWhereUniqueInput
  connectOrCreate: LevelCategoryCreateOrConnectWithoutChildCategoriesInput
  create: LevelCategoryCreateWithoutChildCategoriesInput
}

input LevelCategoryCreateNestedOneWithoutLevelsInput {
  connect: LevelCategoryWhereUniqueInput
  connectOrCreate: LevelCategoryCreateOrConnectWithoutLevelsInput
  create: LevelCategoryCreateWithoutLevelsInput
}

input LevelCategoryCreateOrConnectWithoutChildCategoriesInput {
  create: LevelCategoryCreateWithoutChildCategoriesInput!
  where: LevelCategoryWhereUniqueInput!
}

input LevelCategoryCreateOrConnectWithoutLevelsInput {
  create: LevelCategoryCreateWithoutLevelsInput!
  where: LevelCategoryWhereUniqueInput!
}

input LevelCategoryCreateOrConnectWithoutParentCategoryInput {
  create: LevelCategoryCreateWithoutParentCategoryInput!
  where: LevelCategoryWhereUniqueInput!
}

input LevelCategoryCreateWithoutChildCategoriesInput {
  Levels: LevelCreateNestedManyWithoutCategoryInput
  ParentCategory: LevelCategoryCreateNestedOneWithoutChildCategoriesInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryCreateWithoutLevelsInput {
  ChildCategories: LevelCategoryCreateNestedManyWithoutParentCategoryInput
  ParentCategory: LevelCategoryCreateNestedOneWithoutChildCategoriesInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryCreateWithoutParentCategoryInput {
  ChildCategories: LevelCategoryCreateNestedManyWithoutParentCategoryInput
  Levels: LevelCreateNestedManyWithoutCategoryInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  updatedAt: DateTime
}

input LevelCategoryListRelationFilter {
  every: LevelCategoryWhereInput
  none: LevelCategoryWhereInput
  some: LevelCategoryWhereInput
}

input LevelCategoryMaxOrderByAggregateInput {
  ParentCategoryId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LevelCategoryMinOrderByAggregateInput {
  ParentCategoryId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LevelCategoryNullableRelationFilter {
  is: LevelCategoryWhereInput
  isNot: LevelCategoryWhereInput
}

input LevelCategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input LevelCategoryOrderByWithAggregationInput {
  ParentCategoryId: SortOrder
  _count: LevelCategoryCountOrderByAggregateInput
  _max: LevelCategoryMaxOrderByAggregateInput
  _min: LevelCategoryMinOrderByAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LevelCategoryOrderByWithRelationInput {
  ChildCategories: LevelCategoryOrderByRelationAggregateInput
  Levels: LevelOrderByRelationAggregateInput
  ParentCategory: LevelCategoryOrderByWithRelationInput
  ParentCategoryId: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input LevelCategoryRelationFilter {
  is: LevelCategoryWhereInput
  isNot: LevelCategoryWhereInput
}

enum LevelCategoryScalarFieldEnum {
  ParentCategoryId
  createdAt
  deleteAt
  description
  id
  machineName
  name
  updatedAt
}

input LevelCategoryScalarWhereInput {
  AND: [LevelCategoryScalarWhereInput!]
  NOT: [LevelCategoryScalarWhereInput!]
  OR: [LevelCategoryScalarWhereInput!]
  ParentCategoryId: StringNullableFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input LevelCategoryScalarWhereWithAggregatesInput {
  AND: [LevelCategoryScalarWhereWithAggregatesInput!]
  NOT: [LevelCategoryScalarWhereWithAggregatesInput!]
  OR: [LevelCategoryScalarWhereWithAggregatesInput!]
  ParentCategoryId: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  machineName: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input LevelCategoryUpdateInput {
  ChildCategories: LevelCategoryUpdateManyWithoutParentCategoryNestedInput
  Levels: LevelUpdateManyWithoutCategoryNestedInput
  ParentCategory: LevelCategoryUpdateOneWithoutChildCategoriesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelCategoryUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelCategoryUpdateManyWithWhereWithoutParentCategoryInput {
  data: LevelCategoryUpdateManyMutationInput!
  where: LevelCategoryScalarWhereInput!
}

input LevelCategoryUpdateManyWithoutParentCategoryNestedInput {
  connect: [LevelCategoryWhereUniqueInput!]
  connectOrCreate: [LevelCategoryCreateOrConnectWithoutParentCategoryInput!]
  create: [LevelCategoryCreateWithoutParentCategoryInput!]
  createMany: LevelCategoryCreateManyParentCategoryInputEnvelope
  delete: [LevelCategoryWhereUniqueInput!]
  deleteMany: [LevelCategoryScalarWhereInput!]
  disconnect: [LevelCategoryWhereUniqueInput!]
  set: [LevelCategoryWhereUniqueInput!]
  update: [LevelCategoryUpdateWithWhereUniqueWithoutParentCategoryInput!]
  updateMany: [LevelCategoryUpdateManyWithWhereWithoutParentCategoryInput!]
  upsert: [LevelCategoryUpsertWithWhereUniqueWithoutParentCategoryInput!]
}

input LevelCategoryUpdateOneRequiredWithoutLevelsNestedInput {
  connect: LevelCategoryWhereUniqueInput
  connectOrCreate: LevelCategoryCreateOrConnectWithoutLevelsInput
  create: LevelCategoryCreateWithoutLevelsInput
  update: LevelCategoryUpdateToOneWithWhereWithoutLevelsInput
  upsert: LevelCategoryUpsertWithoutLevelsInput
}

input LevelCategoryUpdateOneWithoutChildCategoriesNestedInput {
  connect: LevelCategoryWhereUniqueInput
  connectOrCreate: LevelCategoryCreateOrConnectWithoutChildCategoriesInput
  create: LevelCategoryCreateWithoutChildCategoriesInput
  delete: LevelCategoryWhereInput
  disconnect: LevelCategoryWhereInput
  update: LevelCategoryUpdateToOneWithWhereWithoutChildCategoriesInput
  upsert: LevelCategoryUpsertWithoutChildCategoriesInput
}

input LevelCategoryUpdateToOneWithWhereWithoutChildCategoriesInput {
  data: LevelCategoryUpdateWithoutChildCategoriesInput!
  where: LevelCategoryWhereInput
}

input LevelCategoryUpdateToOneWithWhereWithoutLevelsInput {
  data: LevelCategoryUpdateWithoutLevelsInput!
  where: LevelCategoryWhereInput
}

input LevelCategoryUpdateWithWhereUniqueWithoutParentCategoryInput {
  data: LevelCategoryUpdateWithoutParentCategoryInput!
  where: LevelCategoryWhereUniqueInput!
}

input LevelCategoryUpdateWithoutChildCategoriesInput {
  Levels: LevelUpdateManyWithoutCategoryNestedInput
  ParentCategory: LevelCategoryUpdateOneWithoutChildCategoriesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelCategoryUpdateWithoutLevelsInput {
  ChildCategories: LevelCategoryUpdateManyWithoutParentCategoryNestedInput
  ParentCategory: LevelCategoryUpdateOneWithoutChildCategoriesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelCategoryUpdateWithoutParentCategoryInput {
  ChildCategories: LevelCategoryUpdateManyWithoutParentCategoryNestedInput
  Levels: LevelUpdateManyWithoutCategoryNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelCategoryUpsertWithWhereUniqueWithoutParentCategoryInput {
  create: LevelCategoryCreateWithoutParentCategoryInput!
  update: LevelCategoryUpdateWithoutParentCategoryInput!
  where: LevelCategoryWhereUniqueInput!
}

input LevelCategoryUpsertWithoutChildCategoriesInput {
  create: LevelCategoryCreateWithoutChildCategoriesInput!
  update: LevelCategoryUpdateWithoutChildCategoriesInput!
  where: LevelCategoryWhereInput
}

input LevelCategoryUpsertWithoutLevelsInput {
  create: LevelCategoryCreateWithoutLevelsInput!
  update: LevelCategoryUpdateWithoutLevelsInput!
  where: LevelCategoryWhereInput
}

input LevelCategoryWhereInput {
  AND: [LevelCategoryWhereInput!]
  ChildCategories: LevelCategoryListRelationFilter
  Levels: LevelListRelationFilter
  NOT: [LevelCategoryWhereInput!]
  OR: [LevelCategoryWhereInput!]
  ParentCategory: LevelCategoryWhereInput
  ParentCategoryId: StringNullableFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input LevelCategoryWhereUniqueInput {
  AND: [LevelCategoryWhereInput!]
  ChildCategories: LevelCategoryListRelationFilter
  Levels: LevelListRelationFilter
  NOT: [LevelCategoryWhereInput!]
  OR: [LevelCategoryWhereInput!]
  ParentCategory: LevelCategoryWhereInput
  ParentCategoryId: StringNullableFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: String
  machineName: String
  name: String
  updatedAt: DateTimeFilter
}

input LevelCountOrderByAggregateInput {
  ParentLevelId: SortOrder
  advance: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  levelCategoryId: SortOrder
  machineName: SortOrder
  name: SortOrder
  percentage: SortOrder
  updatedAt: SortOrder
}

input LevelCreateInput {
  Category: LevelCategoryCreateNestedOneWithoutLevelsInput!
  ChildLevels: LevelCreateNestedManyWithoutParentLevelInput
  ParentLevel: LevelCreateNestedOneWithoutChildLevelsInput
  Project: ProjectCreateNestedManyWithoutLevelInput
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateManyCategoryInput {
  ParentLevelId: String
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateManyCategoryInputEnvelope {
  data: [LevelCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input LevelCreateManyInput {
  ParentLevelId: String
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  levelCategoryId: String!
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateManyParentLevelInput {
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  levelCategoryId: String!
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateManyParentLevelInputEnvelope {
  data: [LevelCreateManyParentLevelInput!]!
  skipDuplicates: Boolean
}

input LevelCreateNestedManyWithoutCategoryInput {
  connect: [LevelWhereUniqueInput!]
  connectOrCreate: [LevelCreateOrConnectWithoutCategoryInput!]
  create: [LevelCreateWithoutCategoryInput!]
  createMany: LevelCreateManyCategoryInputEnvelope
}

input LevelCreateNestedManyWithoutParentLevelInput {
  connect: [LevelWhereUniqueInput!]
  connectOrCreate: [LevelCreateOrConnectWithoutParentLevelInput!]
  create: [LevelCreateWithoutParentLevelInput!]
  createMany: LevelCreateManyParentLevelInputEnvelope
}

input LevelCreateNestedOneWithoutChildLevelsInput {
  connect: LevelWhereUniqueInput
  connectOrCreate: LevelCreateOrConnectWithoutChildLevelsInput
  create: LevelCreateWithoutChildLevelsInput
}

input LevelCreateNestedOneWithoutProjectInput {
  connect: LevelWhereUniqueInput
  connectOrCreate: LevelCreateOrConnectWithoutProjectInput
  create: LevelCreateWithoutProjectInput
}

input LevelCreateOrConnectWithoutCategoryInput {
  create: LevelCreateWithoutCategoryInput!
  where: LevelWhereUniqueInput!
}

input LevelCreateOrConnectWithoutChildLevelsInput {
  create: LevelCreateWithoutChildLevelsInput!
  where: LevelWhereUniqueInput!
}

input LevelCreateOrConnectWithoutParentLevelInput {
  create: LevelCreateWithoutParentLevelInput!
  where: LevelWhereUniqueInput!
}

input LevelCreateOrConnectWithoutProjectInput {
  create: LevelCreateWithoutProjectInput!
  where: LevelWhereUniqueInput!
}

input LevelCreateWithoutCategoryInput {
  ChildLevels: LevelCreateNestedManyWithoutParentLevelInput
  ParentLevel: LevelCreateNestedOneWithoutChildLevelsInput
  Project: ProjectCreateNestedManyWithoutLevelInput
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateWithoutChildLevelsInput {
  Category: LevelCategoryCreateNestedOneWithoutLevelsInput!
  ParentLevel: LevelCreateNestedOneWithoutChildLevelsInput
  Project: ProjectCreateNestedManyWithoutLevelInput
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateWithoutParentLevelInput {
  Category: LevelCategoryCreateNestedOneWithoutLevelsInput!
  ChildLevels: LevelCreateNestedManyWithoutParentLevelInput
  Project: ProjectCreateNestedManyWithoutLevelInput
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelCreateWithoutProjectInput {
  Category: LevelCategoryCreateNestedOneWithoutLevelsInput!
  ChildLevels: LevelCreateNestedManyWithoutParentLevelInput
  ParentLevel: LevelCreateNestedOneWithoutChildLevelsInput
  advance: Int
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  id: String
  machineName: String!
  name: String!
  percentage: Int
  updatedAt: DateTime
}

input LevelListRelationFilter {
  every: LevelWhereInput
  none: LevelWhereInput
  some: LevelWhereInput
}

input LevelMaxOrderByAggregateInput {
  ParentLevelId: SortOrder
  advance: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  levelCategoryId: SortOrder
  machineName: SortOrder
  name: SortOrder
  percentage: SortOrder
  updatedAt: SortOrder
}

input LevelMinOrderByAggregateInput {
  ParentLevelId: SortOrder
  advance: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  levelCategoryId: SortOrder
  machineName: SortOrder
  name: SortOrder
  percentage: SortOrder
  updatedAt: SortOrder
}

input LevelNullableRelationFilter {
  is: LevelWhereInput
  isNot: LevelWhereInput
}

input LevelOrderByRelationAggregateInput {
  _count: SortOrder
}

input LevelOrderByWithAggregationInput {
  ParentLevelId: SortOrder
  _avg: LevelAvgOrderByAggregateInput
  _count: LevelCountOrderByAggregateInput
  _max: LevelMaxOrderByAggregateInput
  _min: LevelMinOrderByAggregateInput
  _sum: LevelSumOrderByAggregateInput
  advance: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  levelCategoryId: SortOrder
  machineName: SortOrder
  name: SortOrder
  percentage: SortOrder
  updatedAt: SortOrder
}

input LevelOrderByWithRelationInput {
  Category: LevelCategoryOrderByWithRelationInput
  ChildLevels: LevelOrderByRelationAggregateInput
  ParentLevel: LevelOrderByWithRelationInput
  ParentLevelId: SortOrder
  Project: ProjectOrderByRelationAggregateInput
  advance: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  id: SortOrder
  levelCategoryId: SortOrder
  machineName: SortOrder
  name: SortOrder
  percentage: SortOrder
  updatedAt: SortOrder
}

input LevelRelationFilter {
  is: LevelWhereInput
  isNot: LevelWhereInput
}

enum LevelScalarFieldEnum {
  ParentLevelId
  advance
  createdAt
  deleteAt
  description
  id
  levelCategoryId
  machineName
  name
  percentage
  updatedAt
}

input LevelScalarWhereInput {
  AND: [LevelScalarWhereInput!]
  NOT: [LevelScalarWhereInput!]
  OR: [LevelScalarWhereInput!]
  ParentLevelId: StringNullableFilter
  advance: IntFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  levelCategoryId: StringFilter
  machineName: StringFilter
  name: StringFilter
  percentage: IntFilter
  updatedAt: DateTimeFilter
}

input LevelScalarWhereWithAggregatesInput {
  AND: [LevelScalarWhereWithAggregatesInput!]
  NOT: [LevelScalarWhereWithAggregatesInput!]
  OR: [LevelScalarWhereWithAggregatesInput!]
  ParentLevelId: StringNullableWithAggregatesFilter
  advance: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  levelCategoryId: StringWithAggregatesFilter
  machineName: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  percentage: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input LevelSumOrderByAggregateInput {
  advance: SortOrder
  percentage: SortOrder
}

input LevelUpdateInput {
  Category: LevelCategoryUpdateOneRequiredWithoutLevelsNestedInput
  ChildLevels: LevelUpdateManyWithoutParentLevelNestedInput
  ParentLevel: LevelUpdateOneWithoutChildLevelsNestedInput
  Project: ProjectUpdateManyWithoutLevelNestedInput
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpdateManyMutationInput {
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpdateManyWithWhereWithoutCategoryInput {
  data: LevelUpdateManyMutationInput!
  where: LevelScalarWhereInput!
}

input LevelUpdateManyWithWhereWithoutParentLevelInput {
  data: LevelUpdateManyMutationInput!
  where: LevelScalarWhereInput!
}

input LevelUpdateManyWithoutCategoryNestedInput {
  connect: [LevelWhereUniqueInput!]
  connectOrCreate: [LevelCreateOrConnectWithoutCategoryInput!]
  create: [LevelCreateWithoutCategoryInput!]
  createMany: LevelCreateManyCategoryInputEnvelope
  delete: [LevelWhereUniqueInput!]
  deleteMany: [LevelScalarWhereInput!]
  disconnect: [LevelWhereUniqueInput!]
  set: [LevelWhereUniqueInput!]
  update: [LevelUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [LevelUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [LevelUpsertWithWhereUniqueWithoutCategoryInput!]
}

input LevelUpdateManyWithoutParentLevelNestedInput {
  connect: [LevelWhereUniqueInput!]
  connectOrCreate: [LevelCreateOrConnectWithoutParentLevelInput!]
  create: [LevelCreateWithoutParentLevelInput!]
  createMany: LevelCreateManyParentLevelInputEnvelope
  delete: [LevelWhereUniqueInput!]
  deleteMany: [LevelScalarWhereInput!]
  disconnect: [LevelWhereUniqueInput!]
  set: [LevelWhereUniqueInput!]
  update: [LevelUpdateWithWhereUniqueWithoutParentLevelInput!]
  updateMany: [LevelUpdateManyWithWhereWithoutParentLevelInput!]
  upsert: [LevelUpsertWithWhereUniqueWithoutParentLevelInput!]
}

input LevelUpdateOneRequiredWithoutProjectNestedInput {
  connect: LevelWhereUniqueInput
  connectOrCreate: LevelCreateOrConnectWithoutProjectInput
  create: LevelCreateWithoutProjectInput
  update: LevelUpdateToOneWithWhereWithoutProjectInput
  upsert: LevelUpsertWithoutProjectInput
}

input LevelUpdateOneWithoutChildLevelsNestedInput {
  connect: LevelWhereUniqueInput
  connectOrCreate: LevelCreateOrConnectWithoutChildLevelsInput
  create: LevelCreateWithoutChildLevelsInput
  delete: LevelWhereInput
  disconnect: LevelWhereInput
  update: LevelUpdateToOneWithWhereWithoutChildLevelsInput
  upsert: LevelUpsertWithoutChildLevelsInput
}

input LevelUpdateToOneWithWhereWithoutChildLevelsInput {
  data: LevelUpdateWithoutChildLevelsInput!
  where: LevelWhereInput
}

input LevelUpdateToOneWithWhereWithoutProjectInput {
  data: LevelUpdateWithoutProjectInput!
  where: LevelWhereInput
}

input LevelUpdateWithWhereUniqueWithoutCategoryInput {
  data: LevelUpdateWithoutCategoryInput!
  where: LevelWhereUniqueInput!
}

input LevelUpdateWithWhereUniqueWithoutParentLevelInput {
  data: LevelUpdateWithoutParentLevelInput!
  where: LevelWhereUniqueInput!
}

input LevelUpdateWithoutCategoryInput {
  ChildLevels: LevelUpdateManyWithoutParentLevelNestedInput
  ParentLevel: LevelUpdateOneWithoutChildLevelsNestedInput
  Project: ProjectUpdateManyWithoutLevelNestedInput
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpdateWithoutChildLevelsInput {
  Category: LevelCategoryUpdateOneRequiredWithoutLevelsNestedInput
  ParentLevel: LevelUpdateOneWithoutChildLevelsNestedInput
  Project: ProjectUpdateManyWithoutLevelNestedInput
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpdateWithoutParentLevelInput {
  Category: LevelCategoryUpdateOneRequiredWithoutLevelsNestedInput
  ChildLevels: LevelUpdateManyWithoutParentLevelNestedInput
  Project: ProjectUpdateManyWithoutLevelNestedInput
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpdateWithoutProjectInput {
  Category: LevelCategoryUpdateOneRequiredWithoutLevelsNestedInput
  ChildLevels: LevelUpdateManyWithoutParentLevelNestedInput
  ParentLevel: LevelUpdateOneWithoutChildLevelsNestedInput
  advance: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  percentage: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LevelUpsertWithWhereUniqueWithoutCategoryInput {
  create: LevelCreateWithoutCategoryInput!
  update: LevelUpdateWithoutCategoryInput!
  where: LevelWhereUniqueInput!
}

input LevelUpsertWithWhereUniqueWithoutParentLevelInput {
  create: LevelCreateWithoutParentLevelInput!
  update: LevelUpdateWithoutParentLevelInput!
  where: LevelWhereUniqueInput!
}

input LevelUpsertWithoutChildLevelsInput {
  create: LevelCreateWithoutChildLevelsInput!
  update: LevelUpdateWithoutChildLevelsInput!
  where: LevelWhereInput
}

input LevelUpsertWithoutProjectInput {
  create: LevelCreateWithoutProjectInput!
  update: LevelUpdateWithoutProjectInput!
  where: LevelWhereInput
}

input LevelWhereInput {
  AND: [LevelWhereInput!]
  Category: LevelCategoryWhereInput
  ChildLevels: LevelListRelationFilter
  NOT: [LevelWhereInput!]
  OR: [LevelWhereInput!]
  ParentLevel: LevelWhereInput
  ParentLevelId: StringNullableFilter
  Project: ProjectListRelationFilter
  advance: IntFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  levelCategoryId: StringFilter
  machineName: StringFilter
  name: StringFilter
  percentage: IntFilter
  updatedAt: DateTimeFilter
}

input LevelWhereUniqueInput {
  AND: [LevelWhereInput!]
  Category: LevelCategoryWhereInput
  ChildLevels: LevelListRelationFilter
  NOT: [LevelWhereInput!]
  OR: [LevelWhereInput!]
  ParentLevel: LevelWhereInput
  ParentLevelId: String
  Project: ProjectListRelationFilter
  advance: IntFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  id: String
  levelCategoryId: StringFilter
  machineName: String
  name: String
  percentage: IntFilter
  updatedAt: DateTimeFilter
}

type Mutation {
  createManyAssignmentArea(data: [AssignmentAreaCreateInput!]!): [AssignmentArea!]!
  createManyLevel(data: [LevelCreateInput!]!): [Level!]!
  createManyLevelCategory(data: [LevelCategoryCreateInput!]!): [LevelCategory!]!
  createManyProcedure(data: [ProcedureCreateInput!]!): [Procedure!]!
  createManyProject(data: [ProjectCreateInput!]!): [Project!]!
  createManyUser(data: [UserCreateInput!]!): [User!]!
  createOneAssignmentArea(data: AssignmentAreaCreateInput!): AssignmentArea!
  createOneLevel(data: LevelCreateInput!): Level!
  createOneLevelCategory(data: LevelCategoryCreateInput!): LevelCategory!
  createOneProcedure(data: ProcedureCreateInput!): Procedure!
  createOneProject(data: ProjectCreateInput!): Project!
  createOneUser(data: UserCreateInput!): User!
  deleteManyAssignmentArea(where: AssignmentAreaWhereInput!): BatchPayload
  deleteManyLevel(where: LevelWhereInput!): BatchPayload
  deleteManyLevelCategory(where: LevelCategoryWhereInput!): BatchPayload
  deleteManyProcedure(where: ProcedureWhereInput!): BatchPayload
  deleteManyProject(where: ProjectWhereInput!): BatchPayload
  deleteManyUser(where: UserWhereInput!): BatchPayload
  deleteOneAssignmentArea(where: AssignmentAreaWhereUniqueInput!): AssignmentArea
  deleteOneLevel(where: LevelWhereUniqueInput!): Level
  deleteOneLevelCategory(where: LevelCategoryWhereUniqueInput!): LevelCategory
  deleteOneProcedure(where: ProcedureWhereUniqueInput!): Procedure
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyAssignmentArea(data: AssignmentAreaUpdateManyMutationInput!, where: AssignmentAreaWhereInput): BatchPayload!
  updateManyLevel(data: LevelUpdateManyMutationInput!, where: LevelWhereInput): BatchPayload!
  updateManyLevelCategory(data: LevelCategoryUpdateManyMutationInput!, where: LevelCategoryWhereInput): BatchPayload!
  updateManyProcedure(data: ProcedureUpdateManyMutationInput!, where: ProcedureWhereInput): BatchPayload!
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneAssignmentArea(data: AssignmentAreaUpdateInput!, where: AssignmentAreaWhereUniqueInput!): AssignmentArea
  updateOneLevel(data: LevelUpdateInput!, where: LevelWhereUniqueInput!): Level
  updateOneLevelCategory(data: LevelCategoryUpdateInput!, where: LevelCategoryWhereUniqueInput!): LevelCategory
  updateOneProcedure(data: ProcedureUpdateInput!, where: ProcedureWhereUniqueInput!): Procedure
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneAssignmentArea(create: AssignmentAreaCreateInput!, update: AssignmentAreaUpdateInput!, where: AssignmentAreaWhereUniqueInput!): AssignmentArea!
  upsertOneLevel(create: LevelCreateInput!, update: LevelUpdateInput!, where: LevelWhereUniqueInput!): Level!
  upsertOneLevelCategory(create: LevelCategoryCreateInput!, update: LevelCategoryUpdateInput!, where: LevelCategoryWhereUniqueInput!): LevelCategory!
  upsertOneProcedure(create: ProcedureCreateInput!, update: ProcedureUpdateInput!, where: ProcedureWhereUniqueInput!): Procedure!
  upsertOneProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedJsonNullableFilter {
  array_contains: Json
  array_ends_with: Json
  array_starts_with: Json
  equals: Json
  not: Json
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

enum NullableJsonNullValueInput {
  DbNull
  JsonNull
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Procedure {
  Project: Project
  createdAt: DateTime!
  deleteAt: DateTime
  id: ID!
  machineName: String!
  name: String!
  projectId: String!
  state: Json!
  updatedAt: DateTime!
}

input ProcedureCountOrderByAggregateInput {
  createdAt: SortOrder
  deleteAt: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  projectId: SortOrder
  state: SortOrder
  updatedAt: SortOrder
}

input ProcedureCreateInput {
  Project: ProjectCreateNestedOneWithoutProceduresInput
  createdAt: DateTime
  deleteAt: DateTime
  id: String
  machineName: String!
  name: String!
  state: Json!
  updatedAt: DateTime
}

input ProcedureCreateManyInput {
  createdAt: DateTime
  deleteAt: DateTime
  id: String
  machineName: String!
  name: String!
  projectId: String!
  state: Json!
  updatedAt: DateTime
}

input ProcedureCreateManyProjectInput {
  createdAt: DateTime
  deleteAt: DateTime
  id: String
  machineName: String!
  name: String!
  state: Json!
  updatedAt: DateTime
}

input ProcedureCreateManyProjectInputEnvelope {
  data: [ProcedureCreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input ProcedureCreateNestedManyWithoutProjectInput {
  connect: [ProcedureWhereUniqueInput!]
  connectOrCreate: [ProcedureCreateOrConnectWithoutProjectInput!]
  create: [ProcedureCreateWithoutProjectInput!]
  createMany: ProcedureCreateManyProjectInputEnvelope
}

input ProcedureCreateOrConnectWithoutProjectInput {
  create: ProcedureCreateWithoutProjectInput!
  where: ProcedureWhereUniqueInput!
}

input ProcedureCreateWithoutProjectInput {
  createdAt: DateTime
  deleteAt: DateTime
  id: String
  machineName: String!
  name: String!
  state: Json!
  updatedAt: DateTime
}

input ProcedureListRelationFilter {
  every: ProcedureWhereInput
  none: ProcedureWhereInput
  some: ProcedureWhereInput
}

input ProcedureMaxOrderByAggregateInput {
  createdAt: SortOrder
  deleteAt: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
}

input ProcedureMinOrderByAggregateInput {
  createdAt: SortOrder
  deleteAt: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  projectId: SortOrder
  updatedAt: SortOrder
}

input ProcedureOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProcedureOrderByWithAggregationInput {
  _count: ProcedureCountOrderByAggregateInput
  _max: ProcedureMaxOrderByAggregateInput
  _min: ProcedureMinOrderByAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  projectId: SortOrder
  state: SortOrder
  updatedAt: SortOrder
}

input ProcedureOrderByWithRelationInput {
  Project: ProjectOrderByWithRelationInput
  createdAt: SortOrder
  deleteAt: SortOrder
  id: SortOrder
  machineName: SortOrder
  name: SortOrder
  projectId: SortOrder
  state: SortOrder
  updatedAt: SortOrder
}

enum ProcedureScalarFieldEnum {
  createdAt
  deleteAt
  id
  machineName
  name
  projectId
  state
  updatedAt
}

input ProcedureScalarWhereInput {
  AND: [ProcedureScalarWhereInput!]
  NOT: [ProcedureScalarWhereInput!]
  OR: [ProcedureScalarWhereInput!]
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  projectId: StringFilter
  state: JsonFilter
  updatedAt: DateTimeFilter
}

input ProcedureScalarWhereWithAggregatesInput {
  AND: [ProcedureScalarWhereWithAggregatesInput!]
  NOT: [ProcedureScalarWhereWithAggregatesInput!]
  OR: [ProcedureScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  machineName: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  projectId: StringWithAggregatesFilter
  state: JsonWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input ProcedureUpdateInput {
  Project: ProjectUpdateOneWithoutProceduresNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProcedureUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProcedureUpdateManyWithWhereWithoutProjectInput {
  data: ProcedureUpdateManyMutationInput!
  where: ProcedureScalarWhereInput!
}

input ProcedureUpdateManyWithoutProjectNestedInput {
  connect: [ProcedureWhereUniqueInput!]
  connectOrCreate: [ProcedureCreateOrConnectWithoutProjectInput!]
  create: [ProcedureCreateWithoutProjectInput!]
  createMany: ProcedureCreateManyProjectInputEnvelope
  delete: [ProcedureWhereUniqueInput!]
  deleteMany: [ProcedureScalarWhereInput!]
  disconnect: [ProcedureWhereUniqueInput!]
  set: [ProcedureWhereUniqueInput!]
  update: [ProcedureUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [ProcedureUpdateManyWithWhereWithoutProjectInput!]
  upsert: [ProcedureUpsertWithWhereUniqueWithoutProjectInput!]
}

input ProcedureUpdateWithWhereUniqueWithoutProjectInput {
  data: ProcedureUpdateWithoutProjectInput!
  where: ProcedureWhereUniqueInput!
}

input ProcedureUpdateWithoutProjectInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProcedureUpsertWithWhereUniqueWithoutProjectInput {
  create: ProcedureCreateWithoutProjectInput!
  update: ProcedureUpdateWithoutProjectInput!
  where: ProcedureWhereUniqueInput!
}

input ProcedureWhereInput {
  AND: [ProcedureWhereInput!]
  NOT: [ProcedureWhereInput!]
  OR: [ProcedureWhereInput!]
  Project: ProjectWhereInput
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  id: StringFilter
  machineName: StringFilter
  name: StringFilter
  projectId: StringFilter
  state: JsonFilter
  updatedAt: DateTimeFilter
}

input ProcedureWhereUniqueInput {
  AND: [ProcedureWhereInput!]
  NOT: [ProcedureWhereInput!]
  OR: [ProcedureWhereInput!]
  Project: ProjectWhereInput
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  id: String
  machineName: StringFilter
  name: StringFilter
  projectId: StringFilter
  state: JsonFilter
  updatedAt: DateTimeFilter
}

type Project {
  account: String!
  archiveBox: String!
  collaborators(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  createdAt: DateTime!
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: ID!
  leader: User!
  leaderId: String!
  level: Level!
  levelId: String!
  machineName: String!
  name: String!
  places: Json
  procedures(cursor: ProcedureWhereUniqueInput, distinct: [ProcedureScalarFieldEnum!], orderBy: [ProcedureOrderByWithRelationInput!], skip: Int, take: Int, where: ProcedureWhereInput): [Procedure!]!
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime!
}

input ProjectAvgOrderByAggregateInput {
  goal: SortOrder
}

input ProjectCountOrderByAggregateInput {
  account: SortOrder
  archiveBox: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  goal: SortOrder
  id: SortOrder
  leaderId: SortOrder
  levelId: SortOrder
  machineName: SortOrder
  name: SortOrder
  places: SortOrder
  progressUnit: SortOrder
  requirements: SortOrder
  transitions: SortOrder
  updatedAt: SortOrder
}

input ProjectCreateInput {
  account: String!
  archiveBox: String!
  collaborators: UserCreateNestedManyWithoutCollaboratorOfInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leader: UserCreateNestedOneWithoutLeaderOfInput!
  level: LevelCreateNestedOneWithoutProjectInput!
  machineName: String!
  name: String!
  places: Json
  procedures: ProcedureCreateNestedManyWithoutProjectInput
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateManyInput {
  account: String!
  archiveBox: String!
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leaderId: String!
  levelId: String!
  machineName: String!
  name: String!
  places: Json
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateManyLeaderInput {
  account: String!
  archiveBox: String!
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  levelId: String!
  machineName: String!
  name: String!
  places: Json
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateManyLeaderInputEnvelope {
  data: [ProjectCreateManyLeaderInput!]!
  skipDuplicates: Boolean
}

input ProjectCreateManyLevelInput {
  account: String!
  archiveBox: String!
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leaderId: String!
  machineName: String!
  name: String!
  places: Json
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateManyLevelInputEnvelope {
  data: [ProjectCreateManyLevelInput!]!
  skipDuplicates: Boolean
}

input ProjectCreateNestedManyWithoutCollaboratorsInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutCollaboratorsInput!]
  create: [ProjectCreateWithoutCollaboratorsInput!]
}

input ProjectCreateNestedManyWithoutLeaderInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLeaderInput!]
  create: [ProjectCreateWithoutLeaderInput!]
  createMany: ProjectCreateManyLeaderInputEnvelope
}

input ProjectCreateNestedManyWithoutLevelInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLevelInput!]
  create: [ProjectCreateWithoutLevelInput!]
  createMany: ProjectCreateManyLevelInputEnvelope
}

input ProjectCreateNestedOneWithoutProceduresInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutProceduresInput
  create: ProjectCreateWithoutProceduresInput
}

input ProjectCreateOrConnectWithoutCollaboratorsInput {
  create: ProjectCreateWithoutCollaboratorsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutLeaderInput {
  create: ProjectCreateWithoutLeaderInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutLevelInput {
  create: ProjectCreateWithoutLevelInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutProceduresInput {
  create: ProjectCreateWithoutProceduresInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutCollaboratorsInput {
  account: String!
  archiveBox: String!
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leader: UserCreateNestedOneWithoutLeaderOfInput!
  level: LevelCreateNestedOneWithoutProjectInput!
  machineName: String!
  name: String!
  places: Json
  procedures: ProcedureCreateNestedManyWithoutProjectInput
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateWithoutLeaderInput {
  account: String!
  archiveBox: String!
  collaborators: UserCreateNestedManyWithoutCollaboratorOfInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  level: LevelCreateNestedOneWithoutProjectInput!
  machineName: String!
  name: String!
  places: Json
  procedures: ProcedureCreateNestedManyWithoutProjectInput
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateWithoutLevelInput {
  account: String!
  archiveBox: String!
  collaborators: UserCreateNestedManyWithoutCollaboratorOfInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leader: UserCreateNestedOneWithoutLeaderOfInput!
  machineName: String!
  name: String!
  places: Json
  procedures: ProcedureCreateNestedManyWithoutProjectInput
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectCreateWithoutProceduresInput {
  account: String!
  archiveBox: String!
  collaborators: UserCreateNestedManyWithoutCollaboratorOfInput
  createdAt: DateTime
  deleteAt: DateTime
  description: String!
  goal: Int!
  id: String
  leader: UserCreateNestedOneWithoutLeaderOfInput!
  level: LevelCreateNestedOneWithoutProjectInput!
  machineName: String!
  name: String!
  places: Json
  progressUnit: String!
  requirements: Json
  transitions: Json
  updatedAt: DateTime
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

input ProjectMaxOrderByAggregateInput {
  account: SortOrder
  archiveBox: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  goal: SortOrder
  id: SortOrder
  leaderId: SortOrder
  levelId: SortOrder
  machineName: SortOrder
  name: SortOrder
  progressUnit: SortOrder
  updatedAt: SortOrder
}

input ProjectMinOrderByAggregateInput {
  account: SortOrder
  archiveBox: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  goal: SortOrder
  id: SortOrder
  leaderId: SortOrder
  levelId: SortOrder
  machineName: SortOrder
  name: SortOrder
  progressUnit: SortOrder
  updatedAt: SortOrder
}

input ProjectNullableRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

input ProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProjectOrderByWithAggregationInput {
  _avg: ProjectAvgOrderByAggregateInput
  _count: ProjectCountOrderByAggregateInput
  _max: ProjectMaxOrderByAggregateInput
  _min: ProjectMinOrderByAggregateInput
  _sum: ProjectSumOrderByAggregateInput
  account: SortOrder
  archiveBox: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  goal: SortOrder
  id: SortOrder
  leaderId: SortOrder
  levelId: SortOrder
  machineName: SortOrder
  name: SortOrder
  places: SortOrder
  progressUnit: SortOrder
  requirements: SortOrder
  transitions: SortOrder
  updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
  account: SortOrder
  archiveBox: SortOrder
  collaborators: UserOrderByRelationAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  description: SortOrder
  goal: SortOrder
  id: SortOrder
  leader: UserOrderByWithRelationInput
  leaderId: SortOrder
  level: LevelOrderByWithRelationInput
  levelId: SortOrder
  machineName: SortOrder
  name: SortOrder
  places: SortOrder
  procedures: ProcedureOrderByRelationAggregateInput
  progressUnit: SortOrder
  requirements: SortOrder
  transitions: SortOrder
  updatedAt: SortOrder
}

enum ProjectScalarFieldEnum {
  account
  archiveBox
  createdAt
  deleteAt
  description
  goal
  id
  leaderId
  levelId
  machineName
  name
  places
  progressUnit
  requirements
  transitions
  updatedAt
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  account: StringFilter
  archiveBox: StringFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  goal: IntFilter
  id: StringFilter
  leaderId: StringFilter
  levelId: StringFilter
  machineName: StringFilter
  name: StringFilter
  places: JsonNullableFilter
  progressUnit: StringFilter
  requirements: JsonNullableFilter
  transitions: JsonNullableFilter
  updatedAt: DateTimeFilter
}

input ProjectScalarWhereWithAggregatesInput {
  AND: [ProjectScalarWhereWithAggregatesInput!]
  NOT: [ProjectScalarWhereWithAggregatesInput!]
  OR: [ProjectScalarWhereWithAggregatesInput!]
  account: StringWithAggregatesFilter
  archiveBox: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  goal: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  leaderId: StringWithAggregatesFilter
  levelId: StringWithAggregatesFilter
  machineName: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  places: JsonNullableWithAggregatesFilter
  progressUnit: StringWithAggregatesFilter
  requirements: JsonNullableWithAggregatesFilter
  transitions: JsonNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input ProjectSumOrderByAggregateInput {
  goal: SortOrder
}

input ProjectUpdateInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  collaborators: UserUpdateManyWithoutCollaboratorOfNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  leader: UserUpdateOneRequiredWithoutLeaderOfNestedInput
  level: LevelUpdateOneRequiredWithoutProjectNestedInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  procedures: ProcedureUpdateManyWithoutProjectNestedInput
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyWithWhereWithoutCollaboratorsInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithWhereWithoutLeaderInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithWhereWithoutLevelInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithoutCollaboratorsNestedInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutCollaboratorsInput!]
  create: [ProjectCreateWithoutCollaboratorsInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutCollaboratorsInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutCollaboratorsInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutCollaboratorsInput!]
}

input ProjectUpdateManyWithoutLeaderNestedInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLeaderInput!]
  create: [ProjectCreateWithoutLeaderInput!]
  createMany: ProjectCreateManyLeaderInputEnvelope
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutLeaderInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutLeaderInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutLeaderInput!]
}

input ProjectUpdateManyWithoutLevelNestedInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutLevelInput!]
  create: [ProjectCreateWithoutLevelInput!]
  createMany: ProjectCreateManyLevelInputEnvelope
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutLevelInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutLevelInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutLevelInput!]
}

input ProjectUpdateOneWithoutProceduresNestedInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutProceduresInput
  create: ProjectCreateWithoutProceduresInput
  delete: ProjectWhereInput
  disconnect: ProjectWhereInput
  update: ProjectUpdateToOneWithWhereWithoutProceduresInput
  upsert: ProjectUpsertWithoutProceduresInput
}

input ProjectUpdateToOneWithWhereWithoutProceduresInput {
  data: ProjectUpdateWithoutProceduresInput!
  where: ProjectWhereInput
}

input ProjectUpdateWithWhereUniqueWithoutCollaboratorsInput {
  data: ProjectUpdateWithoutCollaboratorsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithWhereUniqueWithoutLeaderInput {
  data: ProjectUpdateWithoutLeaderInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithWhereUniqueWithoutLevelInput {
  data: ProjectUpdateWithoutLevelInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithoutCollaboratorsInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  leader: UserUpdateOneRequiredWithoutLeaderOfNestedInput
  level: LevelUpdateOneRequiredWithoutProjectNestedInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  procedures: ProcedureUpdateManyWithoutProjectNestedInput
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutLeaderInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  collaborators: UserUpdateManyWithoutCollaboratorOfNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  level: LevelUpdateOneRequiredWithoutProjectNestedInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  procedures: ProcedureUpdateManyWithoutProjectNestedInput
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutLevelInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  collaborators: UserUpdateManyWithoutCollaboratorOfNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  leader: UserUpdateOneRequiredWithoutLeaderOfNestedInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  procedures: ProcedureUpdateManyWithoutProjectNestedInput
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutProceduresInput {
  account: StringFieldUpdateOperationsInput
  archiveBox: StringFieldUpdateOperationsInput
  collaborators: UserUpdateManyWithoutCollaboratorOfNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  goal: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  leader: UserUpdateOneRequiredWithoutLeaderOfNestedInput
  level: LevelUpdateOneRequiredWithoutProjectNestedInput
  machineName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  places: Json
  progressUnit: StringFieldUpdateOperationsInput
  requirements: Json
  transitions: Json
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpsertWithWhereUniqueWithoutCollaboratorsInput {
  create: ProjectCreateWithoutCollaboratorsInput!
  update: ProjectUpdateWithoutCollaboratorsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutLeaderInput {
  create: ProjectCreateWithoutLeaderInput!
  update: ProjectUpdateWithoutLeaderInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutLevelInput {
  create: ProjectCreateWithoutLevelInput!
  update: ProjectUpdateWithoutLevelInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutProceduresInput {
  create: ProjectCreateWithoutProceduresInput!
  update: ProjectUpdateWithoutProceduresInput!
  where: ProjectWhereInput
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  account: StringFilter
  archiveBox: StringFilter
  collaborators: UserListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  goal: IntFilter
  id: StringFilter
  leader: UserWhereInput
  leaderId: StringFilter
  level: LevelWhereInput
  levelId: StringFilter
  machineName: StringFilter
  name: StringFilter
  places: JsonNullableFilter
  procedures: ProcedureListRelationFilter
  progressUnit: StringFilter
  requirements: JsonNullableFilter
  transitions: JsonNullableFilter
  updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  account: StringFilter
  archiveBox: StringFilter
  collaborators: UserListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  description: StringFilter
  goal: IntFilter
  id: String
  leader: UserWhereInput
  leaderId: StringFilter
  level: LevelWhereInput
  levelId: StringFilter
  machineName: String
  name: StringFilter
  places: JsonNullableFilter
  procedures: ProcedureListRelationFilter
  progressUnit: StringFilter
  requirements: JsonNullableFilter
  transitions: JsonNullableFilter
  updatedAt: DateTimeFilter
}

type Query {
  countAssignmentArea(cursor: AssignmentAreaWhereUniqueInput, distinct: [AssignmentAreaScalarFieldEnum!], orderBy: [AssignmentAreaOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentAreaWhereInput): Int!
  countLevel(cursor: LevelWhereUniqueInput, distinct: [LevelScalarFieldEnum!], orderBy: [LevelOrderByWithRelationInput!], skip: Int, take: Int, where: LevelWhereInput): Int!
  countLevelCategory(cursor: LevelCategoryWhereUniqueInput, distinct: [LevelCategoryScalarFieldEnum!], orderBy: [LevelCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: LevelCategoryWhereInput): Int!
  countProcedure(cursor: ProcedureWhereUniqueInput, distinct: [ProcedureScalarFieldEnum!], orderBy: [ProcedureOrderByWithRelationInput!], skip: Int, take: Int, where: ProcedureWhereInput): Int!
  countProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Int!
  countUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): Int!
  findFirstAssignmentArea(cursor: AssignmentAreaWhereUniqueInput, distinct: [AssignmentAreaScalarFieldEnum!], orderBy: [AssignmentAreaOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentAreaWhereInput): AssignmentArea
  findFirstLevel(cursor: LevelWhereUniqueInput, distinct: [LevelScalarFieldEnum!], orderBy: [LevelOrderByWithRelationInput!], skip: Int, take: Int, where: LevelWhereInput): Level
  findFirstLevelCategory(cursor: LevelCategoryWhereUniqueInput, distinct: [LevelCategoryScalarFieldEnum!], orderBy: [LevelCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: LevelCategoryWhereInput): LevelCategory
  findFirstProcedure(cursor: ProcedureWhereUniqueInput, distinct: [ProcedureScalarFieldEnum!], orderBy: [ProcedureOrderByWithRelationInput!], skip: Int, take: Int, where: ProcedureWhereInput): Procedure
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyAssignmentArea(cursor: AssignmentAreaWhereUniqueInput, distinct: [AssignmentAreaScalarFieldEnum!], orderBy: [AssignmentAreaOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentAreaWhereInput): [AssignmentArea!]!
  findManyLevel(cursor: LevelWhereUniqueInput, distinct: [LevelScalarFieldEnum!], orderBy: [LevelOrderByWithRelationInput!], skip: Int, take: Int, where: LevelWhereInput): [Level!]!
  findManyLevelCategory(cursor: LevelCategoryWhereUniqueInput, distinct: [LevelCategoryScalarFieldEnum!], orderBy: [LevelCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: LevelCategoryWhereInput): [LevelCategory!]!
  findManyProcedure(cursor: ProcedureWhereUniqueInput, distinct: [ProcedureScalarFieldEnum!], orderBy: [ProcedureOrderByWithRelationInput!], skip: Int, take: Int, where: ProcedureWhereInput): [Procedure!]!
  findManyProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findUniqueAssignmentArea(where: AssignmentAreaWhereUniqueInput!): AssignmentArea
  findUniqueLevel(where: LevelWhereUniqueInput!): Level
  findUniqueLevelCategory(where: LevelCategoryWhereUniqueInput!): LevelCategory
  findUniqueProcedure(where: ProcedureWhereUniqueInput!): Procedure
  findUniqueProject(where: ProjectWhereUniqueInput!): Project
  findUniqueUser(where: UserWhereUniqueInput!): User
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum TransactionIsolationLevel {
  Serializable
}

type User {
  assignmentArea: AssignmentArea
  assignmentAreaId: String
  avatar: String!
  collaboratorOf(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  createdAt: DateTime!
  deleteAt: DateTime
  email: String!
  id: ID!
  identification: String!
  leaderOf(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime!
}

input UserCountOrderByAggregateInput {
  assignmentAreaId: SortOrder
  avatar: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  email: SortOrder
  id: SortOrder
  identification: SortOrder
  name: SortOrder
  notifications: SortOrder
  permissions: SortOrder
  position: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  assignmentArea: AssignmentAreaCreateNestedOneWithoutUserInput
  avatar: String!
  collaboratorOf: ProjectCreateNestedManyWithoutCollaboratorsInput
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  leaderOf: ProjectCreateNestedManyWithoutLeaderInput
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserCreateManyAssignmentAreaInput {
  avatar: String!
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserCreateManyAssignmentAreaInputEnvelope {
  data: [UserCreateManyAssignmentAreaInput!]!
  skipDuplicates: Boolean
}

input UserCreateManyInput {
  assignmentAreaId: String
  avatar: String!
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserCreateNestedManyWithoutAssignmentAreaInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutAssignmentAreaInput!]
  create: [UserCreateWithoutAssignmentAreaInput!]
  createMany: UserCreateManyAssignmentAreaInputEnvelope
}

input UserCreateNestedManyWithoutCollaboratorOfInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutCollaboratorOfInput!]
  create: [UserCreateWithoutCollaboratorOfInput!]
}

input UserCreateNestedOneWithoutLeaderOfInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLeaderOfInput
  create: UserCreateWithoutLeaderOfInput
}

input UserCreateOrConnectWithoutAssignmentAreaInput {
  create: UserCreateWithoutAssignmentAreaInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCollaboratorOfInput {
  create: UserCreateWithoutCollaboratorOfInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLeaderOfInput {
  create: UserCreateWithoutLeaderOfInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAssignmentAreaInput {
  avatar: String!
  collaboratorOf: ProjectCreateNestedManyWithoutCollaboratorsInput
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  leaderOf: ProjectCreateNestedManyWithoutLeaderInput
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserCreateWithoutCollaboratorOfInput {
  assignmentArea: AssignmentAreaCreateNestedOneWithoutUserInput
  avatar: String!
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  leaderOf: ProjectCreateNestedManyWithoutLeaderInput
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserCreateWithoutLeaderOfInput {
  assignmentArea: AssignmentAreaCreateNestedOneWithoutUserInput
  avatar: String!
  collaboratorOf: ProjectCreateNestedManyWithoutCollaboratorsInput
  createdAt: DateTime
  deleteAt: DateTime
  email: String!
  id: String
  identification: String!
  name: String!
  notifications: Json
  permissions: Json
  position: String!
  updatedAt: DateTime
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserMaxOrderByAggregateInput {
  assignmentAreaId: SortOrder
  avatar: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  email: SortOrder
  id: SortOrder
  identification: SortOrder
  name: SortOrder
  position: SortOrder
  updatedAt: SortOrder
}

input UserMinOrderByAggregateInput {
  assignmentAreaId: SortOrder
  avatar: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  email: SortOrder
  id: SortOrder
  identification: SortOrder
  name: SortOrder
  position: SortOrder
  updatedAt: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  assignmentAreaId: SortOrder
  avatar: SortOrder
  createdAt: SortOrder
  deleteAt: SortOrder
  email: SortOrder
  id: SortOrder
  identification: SortOrder
  name: SortOrder
  notifications: SortOrder
  permissions: SortOrder
  position: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  assignmentArea: AssignmentAreaOrderByWithRelationInput
  assignmentAreaId: SortOrder
  avatar: SortOrder
  collaboratorOf: ProjectOrderByRelationAggregateInput
  createdAt: SortOrder
  deleteAt: SortOrder
  email: SortOrder
  id: SortOrder
  identification: SortOrder
  leaderOf: ProjectOrderByRelationAggregateInput
  name: SortOrder
  notifications: SortOrder
  permissions: SortOrder
  position: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  assignmentAreaId
  avatar
  createdAt
  deleteAt
  email
  id
  identification
  name
  notifications
  permissions
  position
  updatedAt
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  assignmentAreaId: StringNullableFilter
  avatar: StringFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  email: StringFilter
  id: StringFilter
  identification: StringFilter
  name: StringFilter
  notifications: JsonNullableFilter
  permissions: JsonNullableFilter
  position: StringFilter
  updatedAt: DateTimeFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  assignmentAreaId: StringNullableWithAggregatesFilter
  avatar: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deleteAt: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  identification: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  notifications: JsonNullableWithAggregatesFilter
  permissions: JsonNullableWithAggregatesFilter
  position: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  assignmentArea: AssignmentAreaUpdateOneWithoutUserNestedInput
  avatar: StringFieldUpdateOperationsInput
  collaboratorOf: ProjectUpdateManyWithoutCollaboratorsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identification: StringFieldUpdateOperationsInput
  leaderOf: ProjectUpdateManyWithoutLeaderNestedInput
  name: StringFieldUpdateOperationsInput
  notifications: Json
  permissions: Json
  position: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  avatar: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identification: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  notifications: Json
  permissions: Json
  position: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutAssignmentAreaInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithWhereWithoutCollaboratorOfInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutAssignmentAreaNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutAssignmentAreaInput!]
  create: [UserCreateWithoutAssignmentAreaInput!]
  createMany: UserCreateManyAssignmentAreaInputEnvelope
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAssignmentAreaInput!]
  updateMany: [UserUpdateManyWithWhereWithoutAssignmentAreaInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAssignmentAreaInput!]
}

input UserUpdateManyWithoutCollaboratorOfNestedInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutCollaboratorOfInput!]
  create: [UserCreateWithoutCollaboratorOfInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCollaboratorOfInput!]
  updateMany: [UserUpdateManyWithWhereWithoutCollaboratorOfInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCollaboratorOfInput!]
}

input UserUpdateOneRequiredWithoutLeaderOfNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLeaderOfInput
  create: UserCreateWithoutLeaderOfInput
  update: UserUpdateToOneWithWhereWithoutLeaderOfInput
  upsert: UserUpsertWithoutLeaderOfInput
}

input UserUpdateToOneWithWhereWithoutLeaderOfInput {
  data: UserUpdateWithoutLeaderOfInput!
  where: UserWhereInput
}

input UserUpdateWithWhereUniqueWithoutAssignmentAreaInput {
  data: UserUpdateWithoutAssignmentAreaInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithWhereUniqueWithoutCollaboratorOfInput {
  data: UserUpdateWithoutCollaboratorOfInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutAssignmentAreaInput {
  avatar: StringFieldUpdateOperationsInput
  collaboratorOf: ProjectUpdateManyWithoutCollaboratorsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identification: StringFieldUpdateOperationsInput
  leaderOf: ProjectUpdateManyWithoutLeaderNestedInput
  name: StringFieldUpdateOperationsInput
  notifications: Json
  permissions: Json
  position: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutCollaboratorOfInput {
  assignmentArea: AssignmentAreaUpdateOneWithoutUserNestedInput
  avatar: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identification: StringFieldUpdateOperationsInput
  leaderOf: ProjectUpdateManyWithoutLeaderNestedInput
  name: StringFieldUpdateOperationsInput
  notifications: Json
  permissions: Json
  position: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutLeaderOfInput {
  assignmentArea: AssignmentAreaUpdateOneWithoutUserNestedInput
  avatar: StringFieldUpdateOperationsInput
  collaboratorOf: ProjectUpdateManyWithoutCollaboratorsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  deleteAt: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  identification: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  notifications: Json
  permissions: Json
  position: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutAssignmentAreaInput {
  create: UserCreateWithoutAssignmentAreaInput!
  update: UserUpdateWithoutAssignmentAreaInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutCollaboratorOfInput {
  create: UserCreateWithoutCollaboratorOfInput!
  update: UserUpdateWithoutCollaboratorOfInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutLeaderOfInput {
  create: UserCreateWithoutLeaderOfInput!
  update: UserUpdateWithoutLeaderOfInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  assignmentArea: AssignmentAreaWhereInput
  assignmentAreaId: StringNullableFilter
  avatar: StringFilter
  collaboratorOf: ProjectListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  email: StringFilter
  id: StringFilter
  identification: StringFilter
  leaderOf: ProjectListRelationFilter
  name: StringFilter
  notifications: JsonNullableFilter
  permissions: JsonNullableFilter
  position: StringFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  assignmentArea: AssignmentAreaWhereInput
  assignmentAreaId: StringNullableFilter
  avatar: StringFilter
  collaboratorOf: ProjectListRelationFilter
  createdAt: DateTimeFilter
  deleteAt: DateTimeNullableFilter
  email: String
  id: String
  identification: StringFilter
  leaderOf: ProjectListRelationFilter
  name: StringFilter
  notifications: JsonNullableFilter
  permissions: JsonNullableFilter
  position: StringFilter
  updatedAt: DateTimeFilter
}